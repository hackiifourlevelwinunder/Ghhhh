<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>CSPRNG Live Results</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, Arial; background:#0b1220; color:#e6eef8; margin:0; padding:20px; }
    .card { max-width:800px; margin:16px auto; background:#0f1724; border-radius:12px; padding:18px; box-shadow:0 6px 20px rgba(0,0,0,0.6);}
    h1 { margin:0 0 8px 0; font-size:20px; color:#61dafb;}
    .clock { font-size:18px; color:#bcd6ff; }
    .big { font-size:64px; font-weight:700; text-align:center; margin:18px 0; color:#fff; }
    .meta { text-align:center; color:#9fb4d9; margin-bottom:6px; }
    .history { margin-top:12px; }
    .hist-item { display:flex; justify-content:space-between; padding:8px 12px; border-radius:8px; background:#071029; margin-bottom:8px; align-items:center;}
    .time { color:#9fb4d9; font-size:14px; }
    .num { font-size:22px; font-weight:700; color:#fff; background:#1b2b4a; padding:6px 10px; border-radius:8px;}
    .notice { color:#ffd080; font-size:13px; text-align:center; margin-top:8px;}
  </style>
</head>
<body>
  <div class="card">
    <h1>Live CSPRNG (0–9) — Auto Results</h1>
    <div class="clock" id="clock">--:--:--</div>
    <div class="meta" id="meta">Waiting for server...</div>
    <div class="big" id="current">—</div>
    <div class="notice" id="notice">Result for each minute generated securely on server. It will be revealed 35 seconds before the minute boundary.</div>

    <div class="history" id="history">
      <h3 style="margin-top:12px;color:#9fb4d9">History (latest first)</h3>
      <div id="hist-list"></div>
    </div>
  </div>

<script>
  const clockEl = document.getElementById('clock');
  const currentEl = document.getElementById('current');
  const histList = document.getElementById('hist-list');
  const meta = document.getElementById('meta');
  const notice = document.getElementById('notice');

  // Live clock
  function updateClock() {
    const now = new Date();
    clockEl.textContent = now.toLocaleString('en-IN', { hour12:false });
  }
  setInterval(updateClock, 250);
  updateClock();

  // Maintain history in client
  let history = [];

  function renderHistory() {
    histList.innerHTML = '';
    history.slice().reverse().forEach(item => {
      const div = document.createElement('div');
      div.className = 'hist-item';
      const t = document.createElement('div');
      t.className = 'time';
      const dt = new Date(item.minuteStartIso);
      t.textContent = dt.toLocaleString('en-IN', { hour12:false });
      const n = document.createElement('div');
      n.className = 'num';
      n.textContent = item.number;
      div.appendChild(t);
      div.appendChild(n);
      histList.appendChild(div);
    });
  }

  // Connect SSE
  const es = new EventSource('/events');

  es.addEventListener('init', (e) => {
    try {
      const data = JSON.parse(e.data);
      history = data.history || [];
      meta.textContent = 'Connected. Server time: ' + new Date(data.serverTime).toLocaleString('en-IN', { hour12:false });
      renderHistory();
    } catch(err) {
      console.error('init parse', err);
    }
  });

  es.addEventListener('reveal', (e) => {
    try {
      const entry = JSON.parse(e.data);
      // push to history and update UI
      history.push(entry);
      if (history.length > 500) history.shift();
      renderHistory();
      // Show the revealed number as "current"
      currentEl.textContent = entry.number;
      meta.textContent = 'Revealed for minute starting at: ' + new Date(entry.minuteStartIso).toLocaleString('en-IN', { hour12:false });
      // flash notice briefly
      notice.textContent = 'New result revealed (35s before minute).';
      setTimeout(()=> notice.textContent = 'Result for each minute generated securely on server. It will be revealed 35 seconds before the minute boundary.', 5000);
    } catch(err) {
      console.error('reveal parse', err);
    }
  });

  es.onerror = (ev) => {
    meta.textContent = 'Connection lost, retrying...';
  };

  // Keep showing when next reveal will happen based on server time + last reveal
  // No polling required; SSE pushes reveal events when they occur.
</script>
</body>
</html>